---
layout:   post
title:    ""
date:     2019-5-24
author:   "王玉松"
header-img: ""
tags:
    - Fibonacci
    - 楼梯问题
    - 递归
---

# 递归算法（上）

## 一、Fibonacci数列

```textile
    提到递归算法中最经典的案例始终无法绕开的就是Fibonacci数列。
    Fibonacci数列又称黄金分割数列、因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入。
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ·····
```

## 二、楼梯问题

```text
    题目：15级楼梯，一个人每次只能爬1级或2级台阶，问有多少种方案爬完楼梯。
    解答：考虑这类问题首先是根据已知的条件设定基本情况。
    （1）基本情况：
        一级台阶时，只有一种方案（直接一步跨上去）；		F(1)=1
        两级台阶时，有两种方案（一次性跨两步，连跨两步）； F(2)=2
        三级台阶时······

        接下来，在台阶数目可以接受的范围内，我们依然可以较为方便的给出全部可能的方案。
        但是，一旦台阶数目超过一定的范围（比如1000），短时间内人工计算很难得出结果。
        从第一步的选择（跨1级，跨两级）开始，每步都有两种可能性，如果在纸上以二叉树的形式画出这个问题的解决方案，可以想象出，
        将会形成一个很大的二叉树，结果只要数清楚二叉树的叶节点即可，从根节点到每一个叶节点都是一种可能的方案，思路仍然是十分清楚的。
        但是计算方法却存在问题，计算时间过长，数据过多，极容易出错。
        可以看见，我们是根据正向的思维出发，从第一步一直走到最后一步，每一步的选择都将我们引到两条路上，一变二，二变四，四变八，
        以几何级数的方式向上增加，这种计算量让计算机都不一定能吃得消，何况是人。
        结合Fibonacci数列的计算形式，我们可以得到一种较为简便的计算形式。
        Fibonnacci数列中，当n大于等于2时，F(n) = F(n-1) + F(n-2)，每一项等于前面两项之和。
```

```textile
	采用Fibonnacci数列递归计算的形式，从推理上而言，确实更加容易理解，也更加巧妙，15级台阶走最后一步的情况，肯定只有两种：
  从13级跨两步或者是从14级跨一步，F(15) = F(13) + F(14)
  这就是从第一级台阶走到15级台阶的全部情况（在已知F(13)和F(14)的数值的情况下，可以用加法直接计算出结果）。
	问题被分解成两大部分，求解F(13)和F(14)，如何求解F(13)和F(14)？
	根据求解F(15)的步骤将F(13)和F(14)再次拆分，F(13) = F(12) + F(11)，F(14) = F(13) + F(12)
	如此类推，我们可以确定，最后的计算必然是涉及到F(1)和F(2) ，而F(1)和F(2)的取值我们在基本情况中已经确定了，只要反向带入一层一层推出F(n)的取值即可。
```

```c
#include <stdio.h> 

int f(int n)
{
    if(n == 1)         return 1;
    else if(n == 2)    return 2;
    else               return f(n-1) + f(n-2);
}

int main()
{
    printf("%d\n",f(100));
    return 0;
}
```

```textile
不过，这个问题可没有这么容易解决。用实际的例子说明，计算f(1000)，或者尝试使用计算机计算f(50)，其结果等待时间不忍直视。
递归算法在形式上更容易被人理解，而非实际交给计算机去计算，如果想要实现此类问题，要将递归改成递推的形式。
```

## 参考资料：

- [Fibonacci数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145)
